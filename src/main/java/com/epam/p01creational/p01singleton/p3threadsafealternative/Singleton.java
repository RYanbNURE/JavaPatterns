package com.epam.p01creational.p01singleton.p3threadsafealternative;

public class Singleton {
    // Приватний конструктор, що запобігає безпосередньому інстанціюванню класу.
    private Singleton() {}

    // Внутрішній статичний клас-хелпер для зберігання екземпляру Singleton.
    private static class SingletonHolder {
        // Статичний фінальний елемент, що містить єдиний екземпляр класу Singleton.
        public static final Singleton INSTANCE = new Singleton();
    }

    // Метод для отримання єдиного екземпляру класу Singleton.
    // Цей метод синхронізовано по класа, що запобігає багатьом потокам одночасно створювати нові екземпляри.
    public static synchronized Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}

/*
### Пояснення:
1. **Приватний конструктор**: `private Singleton()` запобігає безпосередньому інстанціюванню класу ззовні.
2. **Внутрішній статичний клас-хелпер**: `SingletonHolder` є внутрішнім класом, який доступний тільки для самого класу `Singleton`. Це гарантує, що він буде ініціалізований лише при першому виклику
методу `getInstance()`.
3. **Статичний фінальний елемент**: `INSTANCE` є статичним та фінальним елементом класу `SingletonHolder`, який містить єдиний екземпляр класу `Singleton`. Це запобігає можливості змінити цей елемент
після його ініціалізації.
4. **Метод getInstance()**: Синхронізовано по класа, що гарантує, що тільки один потік може створити новий екземпляр `Singleton` при першому виклику методу. Для наступних викликів, коли екземпляр вже
існує, метод просто повертає існуючий екземпляр, що економить ресурси.

Цей підхід забезпечує безперервну роботу в багатьох потоках та ефективно використовує механізми синхронізації в Java, не вимагаючи додаткових затрат на блокування у важкому циклі.
 */
